const IsFnRegex = /^\s*(?:function)?\*/
const hasToStringTag = typeof Symbol === 'function' && typeof Symbol.toStringTag === 'symbol'
const getProto = Object.getPrototypeOf
const ToString = Function.prototype.toString;
const hasOwn = Object.prototype.hasOwnProperty;
const toStr = Object.prototype.toString;
const getGeneratorFunc = () => {
  if (!hasToStringTag) {
    return false;
  }
  try {
    return Function('return function*() {}')();
  } catch (e) {
  }
}
const generatorFunc = getGeneratorFunc();
const GeneratorFunction = generatorFunc ? getProto(generatorFunc) : {};
/**
 * 判断指定对象是否时类
 * @param obj 指定对象
 * @param strict
 * @constructor
 */
export const isClass = (obj: any,strict?:any) => {
  if (typeof obj != "function") return false;
  const str = obj.toString();
  // async function or arrow function
  if (obj.prototype === undefined) return false;
  // generator function or malformed definition
  if (obj.prototype.constructor !== obj) return false;
  // ES6 class
  if (str.slice(0, 5) == "class") return true;
  // has own prototype properties
  if (Object.getOwnPropertyNames(obj.prototype).length >= 2) return true;
  // anonymous function
  if (/^function\s+\(|^function\s+anonymous\(/.test(str)) return false;
  // ES5 class without `this` in the body and the name's first character
  // upper-cased.
  if (strict && /^function\s+[A-Z]/.test(str)) return true;
  // has `this` in the body
  if (/\b\(this\b|\bthis[\.\[]\b/.test(str)) {
    // not strict or ES5 class generated by babel
    if (!strict || /classCallCheck\(this/.test(str)) return true;

    return /^function\sdefault_\d+\s*\(/.test(str);
  }
  return false;
}

/**
 * 判断是否是正则
 * @param obj
 */
export const isRegExp = (obj:any):boolean=>{
  return toStr.call(obj) === "[object RegExp]"
}

/**
 * 判断是否是方法
 * @param obj
 */
export const isFunction = (obj:any):boolean=>{
  return typeof obj==="function"
}

/**
 * 判断是否是异步方法
 * @param obj
 */
export const isAsyncFunction = (obj:any):boolean=>{
  return toStr.call(obj)==="[object AsyncFunction]"
}

/**
 * 判断是否时纯对象
 * @param obj
 */
export const isPlainObject =  (obj) =>{
  if (!obj || toStr.call(obj) !== '[object Object]') {
    return false;
  }

  const hasOwnConstructor = hasOwn.call(obj, 'constructor');
  const hasIsPrototypeOf =
    obj.constructor &&
    obj.constructor.prototype &&
    hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
  // Not own constructor property must be Object
  if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
    return false;
  }

  // Own properties are enumerated firstly, so to speed up,
  // if last one is own, then all properties are own.
  let key;
  for (key in obj) {
    /**/
  }

  return typeof key === 'undefined' || hasOwn.call(obj, key);
}

/**
 * 判断是否是create工厂
 * @param obj
 */
export const isGeneratorFunction = (obj:any):boolean=>{
  if (typeof obj !== 'function') {
    return false;
  }
  if (IsFnRegex.test(ToString.call(obj))) {
    return true;
  }
  if (!hasToStringTag) {
    const str = toStr.call(obj);
    return str === '[object GeneratorFunction]';
  }
  return getProto(obj) === GeneratorFunction;
}

/**
 * 判断是否是Promise
 * @param obj
 */
export const isPromise = (obj:any):boolean => {
  return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
}

/**
 * 对象判断
 */
export const Types = {
  isClass,
  isRegExp,
  isPromise,
  isFunction,
  isPlainObject,
  isAsyncFunction,
  isGeneratorFunction
}